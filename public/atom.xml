<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱思考的文文子</title>
  
  <subtitle>Blogging to Collect Parts of My Life</subtitle>
  <link href="http://www.wenwenziy.live/atom.xml" rel="self"/>
  
  <link href="http://www.wenwenziy.live/"/>
  <updated>2021-10-16T03:39:59.792Z</updated>
  <id>http://www.wenwenziy.live/</id>
  
  <author>
    <name>文文子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>吹散尘世的疾风</title>
    <link href="http://www.wenwenziy.live/2021/10/%E5%90%B9%E6%95%A3%E5%B0%98%E4%B8%96%E7%9A%84%E7%96%BE%E9%A3%8E/"/>
    <id>http://www.wenwenziy.live/2021/10/%E5%90%B9%E6%95%A3%E5%B0%98%E4%B8%96%E7%9A%84%E7%96%BE%E9%A3%8E/</id>
    <published>2021-10-16T03:25:39.000Z</published>
    <updated>2021-10-16T03:39:59.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2021-10-12-记"><a class="markdownIt-Anchor" href="#2021-10-12-记"></a> 2021-10-12 记</h2><p>今天不知道怀着怎样的心情，我又把上午的抽象代数课翘了。哦，我想起来大概是因为又自大地想着自己可以利用好自己的时间，赶一下其他课的进度（今天是看了一张实变函数，正因此才顺利地解决掉上周的实变作业）。</p><span id="more"></span><p>下午离散代数，因为放了太久的假，我都忘记了要去哪里上课。直到2点过的时候，走到教5三楼才发现，上课的教室并不在教五（惊出一身冷汗）。我一直觉得离散代数很简单，但是各种细节堆积起来，记忆起来也是很要命的。这又让我想起了那个话题——学习数学究竟靠理解更多，还是靠记忆更多？前者只有记住一些关键的思想、方法，就可以凭自己的逻辑展开一套理论；后者则是需要长时间的训练和打磨，依靠记忆培养思维，才能养成解决一类的问题的思路和直觉。</p><p>晚间，决定放弃掉拓扑学了，毕竟我不能在自己还什么都做的时候对自己期许太高。如果我真的努力了，也确实觉得顾不过来的话，放弃也不是为一种智慧的选择。</p><p>今天的玩乐部分，重新看了一遍命运石之门的剧场（助手拯救胸针的那个），一直无法释怀的一段话，我觉得想把它们记在这里。</p><p>—你知道凤凰院凶真吗？<br />—凤凰院？<br />—他是个科学家，但又不是普通的科学家。他是个疯狂科学家，疯狂的程度无人能及。<br />他的言行总是乱七八糟，<br />总被周围的人笑话。<br />没人相信他的话，<br />和他的研究以及发现。<br />可是，<br />他发现的东西除了他以外谁都看不见。<br />他发觉那东西会使人痛苦，使人受伤。<br />有时甚至会毁灭世界。<br />所以他拼命的想要保护大家，<br />他为了拯救世界不断战斗着。<br />最后，他成功的守护了所有人，<br />但这件事却无人知晓。<br />他也依然是个疯狂科学家，<br />持续不断的被大家笑话。<br />—真是个悲伤的故事啊。<br />—是吗？我倒觉得这是个精彩的故事。</p><p>我很喜欢它的原因大概是其中蕴含着的一种价值，面对像傻瓜一样的人——可以不顾世俗的眼光和评价拼尽全力去拯救他人的人——这种价值不会为其感到悲慨，不会觉得那个人落寞万分难耐凄凉，这种价值之所以鼓动人心就是因为它超越了世俗的声音，呈现了人真正的某种向往，某种执着，某个追求，它在呼唤——所谓心向往之，至死不渝。受尽冷眼又何妨，屡遭失败又何妨，这样的人恰恰是最不应该被嘲笑和最需要我们去理解的人。这样的人从来都不是傻瓜，那些对其视而不见的人们才是。</p><p>不知道为什么，我看这种类型的故事总是容易哭成麻瓜，真是一个悲伤的故事啊。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;2021-10-12-记&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#2021-10-12-记&quot;&gt;&lt;/a&gt; 2021-10-12 记&lt;/h2&gt;
&lt;p&gt;今天不知道怀着怎样的心情，我又把上午的抽象代数课翘了。哦，我想起来大概是因为又自大地想着自己可以利用好自己的时间，赶一下其他课的进度（今天是看了一张实变函数，正因此才顺利地解决掉上周的实变作业）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="少年少女的日记" scheme="http://www.wenwenziy.live/tags/%E5%B0%91%E5%B9%B4%E5%B0%91%E5%A5%B3%E7%9A%84%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>告慰未来</title>
    <link href="http://www.wenwenziy.live/2021/10/%E5%91%8A%E6%85%B0%E6%9C%AA%E6%9D%A5/"/>
    <id>http://www.wenwenziy.live/2021/10/%E5%91%8A%E6%85%B0%E6%9C%AA%E6%9D%A5/</id>
    <published>2021-10-16T03:23:17.000Z</published>
    <updated>2021-10-16T03:39:45.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2021-10-11-记"><a class="markdownIt-Anchor" href="#2021-10-11-记"></a> 2021-10-11 记</h2><p>我思考了很久，尝试了很久，一直很想要做到的一件事情——是将无论是悲伤的，喜悦的过去通通铭记，等到在漫长的旅途中遇见一个人，将这些倾囊相授。不吐不快似的，我希望我的故事得以在他人身上延续，不至于流亡迷失在我这颗穷困潦倒的头脑。</p><span id="more"></span><p>可是我发现人想要一直记住生活中发生的事情，简直比登天还要困难。就拿日常的社交来说，想要不过错重要的消息几乎是不可能的，更别说在此基础上还要保证学习的记录，各种日常事件、待办事项的记录。</p><p>到底有什么方法，可以让我记住那些感动与释怀，让我记住教训，记住原则，不要一次又一次犯下令自己懊悔难过的错误？我知道有那么一天，曾经常常给予我欢欣鼓舞的事物们将沦为俗常朴实的生活，那些令我苦恼不堪的事情将成为付诸谈笑的一汪苦水淹没在唇齿间，以及诸多感动、伤怀、泪水，耀眼的晴空，沁人的古树，神秘的一口井，遗失的一把匙，停在路边的脚踏车，盘旋在耳边的晚间风，会不会都成为支离破碎的回忆。再记不清思念之人的名字，再想不清重要的话语，再也无法想见那时那年，普通却又宝贵的日常。</p><p>于是，今天我想记得一点就索性写一点。把那么在意的那么用尽浑身解数去生活的自己记录下来。哪怕烧成灰呀，也得让在未来会陷入消沉和迷茫的自己听到啊……</p><p>今天，你很努力了，上午的两门课基本都是大脑在线，没有开小差，没有拿空余时间去干别的事情。实变函数目前还算简单，没有进入复杂的积分理论；数学物理方程细节很多，关于laplace变换和fourier变换的内容，我基本没底，需再多花点时间来熟悉；优化理论今天是上机课，有两道线性规划的题目作为上机作业（记得要及时完成）。</p><p>我记得上机课你倒是全程投入，除了中途摆弄了一下如何用 vim 来写 matlab （需要用到 <code>vim-matlab</code> 插件，有一种方法是把 matlab 的编译器链接到 bin 文件夹里去，然后就可以作为系统执行文件来调用了（但是需要关闭系统完整性保护）；另一种方法是用 py 脚本完成 matlab 线上端和本地的通信，上传编译出结果（没后文了）。</p><p>今天也算是终于完成了你心心念念的数据结构作业，老师安排的题目真的有点太笼统，想写的精细一点会很花时间（比如各种调试，考量类的拓展性和复用性，考虑是不是方便使用，结果输出是不是一目了然），写得简单一点的话直接用模拟的方法就可以搞定。</p><p>晚上和小A出去吃小川料理，我记得炸鸡和拉面都很不错，凉菜（凉拌蛤蜊）的口感也很新鲜。再之后去图书馆自习，小A是真的放不下玩手机，得亏我还提醒了几次。</p><p>总之，要是下周周一，你还在想着躺平这种事，还在盘算着要不要破罐子破摔的事情，并且还将我的心愿和梦想通通忘记了的话，那就请你回头看看这段文字。你要继续前行，我终将随时间的流逝悄然逝去，为你留下的是今天的墓志铭。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;2021-10-11-记&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#2021-10-11-记&quot;&gt;&lt;/a&gt; 2021-10-11 记&lt;/h2&gt;
&lt;p&gt;我思考了很久，尝试了很久，一直很想要做到的一件事情——是将无论是悲伤的，喜悦的过去通通铭记，等到在漫长的旅途中遇见一个人，将这些倾囊相授。不吐不快似的，我希望我的故事得以在他人身上延续，不至于流亡迷失在我这颗穷困潦倒的头脑。&lt;/p&gt;</summary>
    
    
    
    
    <category term="少年少女的日记" scheme="http://www.wenwenziy.live/tags/%E5%B0%91%E5%B9%B4%E5%B0%91%E5%A5%B3%E7%9A%84%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>致无法忘怀和终将忘却的</title>
    <link href="http://www.wenwenziy.live/2021/10/%E8%87%B4%E6%97%A0%E6%B3%95%E5%BF%98%E6%80%80%E5%92%8C%E7%BB%88%E5%B0%86%E5%BF%98%E5%8D%B4%E7%9A%84/"/>
    <id>http://www.wenwenziy.live/2021/10/%E8%87%B4%E6%97%A0%E6%B3%95%E5%BF%98%E6%80%80%E5%92%8C%E7%BB%88%E5%B0%86%E5%BF%98%E5%8D%B4%E7%9A%84/</id>
    <published>2021-10-07T03:26:00.000Z</published>
    <updated>2021-10-16T03:40:14.281Z</updated>
    
    <content type="html"><![CDATA[<p>解构幻想，抱着踏实的实存感纵身跃下，我会落脚在何方呢？</p><span id="more"></span><p>最近，我回味故人往事的时候，常常会试着构想在未来和他们再次相遇的情景。小A成为了知名的模特，小B应该会是一个不错的插画家，小C成为了不眠不休的加班族……如果是小宋的话，他人那么好、幽默风趣，又看得开，应该到哪里都能遇见不错的的人，交上一群无肉不欢的朋友；如果是小方，聪明脑袋做一番大事业应该也不成问题；小九话那么少，大概会遇上某个热情开朗的女生，把整个青春期的苦恼发泄一通，然后有一个幸福的家庭吧。</p><p>但是，不会不也有我意想不到的展开。记得，我高中一次校园环跑的途中，大喘气地问了一句，对着平日里一直喜欢打扰我的小鬼，“我问你诶，从小到大这十几年来的人生，你对这个世界有什么想法吗？”他完全不假思索地就问答道：“没有啊，怎么了。”像他这样的，莫名其妙从生活中获得许多又将失去许多的人，会不会在未来的某天突然告诉我答案呢？</p><p>或者，某个已经被遗忘到角落的同学，忽然在同学会上听闻到ta的死讯。大家大多都印象不深，只有我一人记得那些斑斑驳驳的对话。随后，只好由我来追逐旧日的线索，还自己一份心安。</p><p>那么我呢？这下该轮到我自己了吧。然而，我却一点儿也见不到我的未来：成为一个矜矜业业的上班族（不禁涌起一股恶寒）；成为一个不错的老师（说不定会家长们被排挤）；一辈子旅行，认识许多人，拥有一份份温馨美好的日常（我大概是没有那个经济实力的）；陷入存在主义危机，抑郁症爆发，内分泌失调，英年早逝（好惨)……</p><p>在种种的未来里，我似乎要与许多人分道扬镳（因为他们从来不知道我抱着怎样的妄想），我从未想见我该以怎样一副面孔迎上那些我珍惜过，倾诉过这份妄想的人（因为我已经看见将来的艰辛，害怕食言，害怕度过一个又一个悔恨 的年月）。在只有我存在的城市里，在远离所有过往的岁月里，是不是就可以不用面对这些了？</p><p>在无法忘怀与终将忘却的时光里，我只能一次又一次进行这样的幻想，仿佛寄往无名氏的信件。直到……</p><p>被困意吞没……</p><p>明天又是新的一天，如果掉到异世界当我没说。晚安。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;解构幻想，抱着踏实的实存感纵身跃下，我会落脚在何方呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="少年少女的日记" scheme="http://www.wenwenziy.live/tags/%E5%B0%91%E5%B9%B4%E5%B0%91%E5%A5%B3%E7%9A%84%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-课程笔记</title>
    <link href="http://www.wenwenziy.live/2021/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.wenwenziy.live/2021/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2021-10-03T04:30:11.000Z</published>
    <updated>2021-10-16T03:38:52.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法"><a class="markdownIt-Anchor" href="#数据结构与算法"></a> 数据结构与算法</h1><h2 id="什么是数据结构"><a class="markdownIt-Anchor" href="#什么是数据结构"></a> 什么是数据结构？</h2><p>要理解数据结构，首先从目的、功能的角度看。计算机要解决一个具体的问题，大致需要经过如下几个步骤：</p><ol><li>分析问题，确定数据模型</li><li>设计相应的算法</li><li>编写程序，运行并调试，直至得到正确的结果</li></ol><p>这里提出了一个概念叫做 <strong>数据模型</strong> 。作为一个数学系应用数学专业的学生，我一个想到的是既然都叫做模型，那么数据模型和数学模型有什么异同呢？</p><p>首先一个最令人困惑的问题是数学、数据，这两个词到底有什么区别？（我最近比较喜欢用这种分析语义语词的方式理解问题）。参考百度上的解释：</p><ul><li><strong>数学</strong> 作为学科，其目的在于研究数量、结构、变化、空间以及信息等概念。作为思维方法，是人类对事物的抽象结构与模式进行严格描述的一种通用手段。</li><li><em>与其说是通用手段，不如说每每当人类将问题给抽象化，特征化，便无可避免地使用（亦或是发明）某种“数学”</em>。</li><li><strong>数据</strong> 作为类，是指对客观事件进行记录并可以鉴别的符号，是对客观事物的逻辑归纳。数据经过加工和处理成为可被解读的信息。</li></ul><span id="more"></span><p>至此，我觉得可以给出一个更加清晰的定义：数学是对世界的抽象化，而数据是对世界的符号化。数学抽象的结果最终表现一整套的数学理论（由公理，命题和论证组成），而数据符号化的结构最终表现为符号以及符号之间关系构成的集合与现实世界的对应关系（如计算机中的二进制mp3文件和播放出来的声音之间的关系）。</p><p>在这本数据结构的教材中，数据的定义更加切实，作者非常直接了当地指出：“<strong>数据是描述客观事物的数和字符组成的集合</strong>，是所有能够被输入到计算机中，且能够被计算机处理的符号的集合”。</p><p>从数据作为集合的概念延展开来，我们不难理解数据集合中的元素称为 <strong>数据项</strong>，数据集合的子集称为 <strong>数据对象</strong>，数据集合上的关系称为 <strong>数据结构</strong> 。</p><p>其中，数据项是保持数据所代表含义的独立性的最小单位，例如一名学生的学号为20192025xxx，不能再进一步拆分处理，否则便会丧失其具体的含义。</p><p>数据对象是保持性质相同的数据元素共同构成的集合。所谓“性质”，一般指的是这个集合中的每个元素对应地描述了一类性质相同对象，而非是在说数据元素本身有什么性质。例如ASCII编码构成的数据对象共同描述了计算机可以表示的符号和形状。</p><p>数据结构是数据集合上的关系。这样的关系往往是人们通过分析现实问题认为建构出来的，与数据本身取值多少可能没有必然联系。</p><p>最后一点，是数据结构的层次问题。通常来讲，数据结构包含着两方面的层次，分别是逻辑结构和存储结构，以刻画数据含义之间的逻辑关系（与具体的问题有关）和数据在计算机电子构件中的存储表示及其关系。任何对数据结构的改动，从某种意义上讲，都可以被称之为数据的 <strong>运算</strong>，由于数据结构的不同层次，运算既可以是更改数据在计算机中的存储关系的各种操作，也可以是对现实事物之间关系的刻画。</p><h3 id="逻辑结构及其表示"><a class="markdownIt-Anchor" href="#逻辑结构及其表示"></a> 逻辑结构及其表示</h3><p>在现实世界中数据元素之间关系是多种多样的，但在数据结构中主要讨论数据之间的相邻关系或者邻接关系。</p><h4 id="逻辑结构的分类"><a class="markdownIt-Anchor" href="#逻辑结构的分类"></a> 逻辑结构的分类</h4><p>按类型划分，我们对数据的逻辑结构作归纳，无外乎如下几类：</p><dl><dt>1.<strong>集合</strong></dt><dd>集合是指数据元素之间除了属于同一个集合的关系之外，再没有其他关系的集合。</dd><dt>2.<strong>线性结构</strong></dt><dd>线性结构(linear structure)是指该结构中的数据元素之间存在一对一的关系。其特点是除了唯二两个起点和终点仅有一个唯一的前驱（或后继）以外，其余的每一个数据元素均各有一个前驱元素和后继元素。</dd><dt>3.<strong>树形结构</strong></dt><dd>树形结构是指该结构中的数据元素存在一对多的关系，除了为唯一一个顶点没有前驱元素，以及树叶节点没有后继元素外，其余每一d个数据元素均有一个前驱元素以及至少一个后继元素。</dd><dt>4.<strong>图形结构</strong></dt><dd>图形结构是指该结构中数据元素之间存在多对多的关系，每个数据元素的前驱和后继的个数可以使任意的。</dd></dl><h4 id="逻辑结构的表示"><a class="markdownIt-Anchor" href="#逻辑结构的表示"></a> 逻辑结构的表示</h4><dl><dt>（1） 图表表示</dt><dd>图表表示就是直接按顺序编号，把数据项在一张表格中列出来。例如：</dd></dl><table><thead><tr><th style="text-align:center">学号</th><th style="text-align:center">姓名</th><th style="text-align:center">性别</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">张斌</td><td style="text-align:center">男</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">刘丽</td><td style="text-align:center">女</td></tr><tr><td style="text-align:center">34</td><td style="text-align:center">李英</td><td style="text-align:center">女</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">陈华</td><td style="text-align:center">男</td></tr></tbody></table><dl><dt>（2） 集合（二元组）表示</dt><dd>我们称一个元素集合和一个关系二元关系集合构成一个逻辑结构的二元组，一个二元组的表示如下：</dd></dl><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><mi>D</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B=(D,R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 为数据项构成的集合，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 上的二元关系集合。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>=</mo><mo stretchy="false">{</mo><mi>d</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi mathvariant="normal">∣</mi><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>n</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D=\{d\_i | 1 \le i \le n, n \ge 0 \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">{</span><span class="mord mathdefault">d</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span><span class="mord">∣</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">}</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>=</mo><mo stretchy="false">{</mo><mi>r</mi><mi mathvariant="normal">_</mi><mi>j</mi><mi mathvariant="normal">∣</mi><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>m</mi><mo separator="true">,</mo><mi>m</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R = \{r\_j | 1 \le j \le m, m \ge 0 \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">∣</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">}</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi mathvariant="normal">_</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">d\_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">d</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span></span></span></span> 表示集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 中的第 i 个元素，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 中元素的个数。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi mathvariant="normal">_</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">r\_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9695199999999999em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span></span></span></span> 表示集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 中的第i种关系，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 中的关系个数。对于关系集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi mathvariant="normal">_</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">r\_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9695199999999999em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span></span></span></span> 来说，集合中的每一个元素为 \<x,y\>, x,y \in D 代表元素x<br />与元素y之间存在相邻关系（&lt;前驱，后继&gt;）。</p><dl><dt>（3）图形表示</dt><dd>简单地用一个圆圈+数字来表示节点，用箭头来表示相邻关系。可以做出如下的图形</dd></dl><p><img src="https://picofwwzy-1307689287.cos.ap-shanghai.myqcloud.com/uPic/20211003.png" alt="20211003" /></p><p>其二元组表示为：</p> \begin{aligned}& B = \{ 25, 36, 48, 57, 64, 82, 75 \} \\ & D = \{ r\_1, r\_2 \} \\& r\_1 = \{ \<48,25\>, \<25,36\>, \<48,64\>, \<64,57\>, \<64,82\>, \<82,75\> \}\\& r\_2 = \{ \<25,36\>, \<36,48\>, \<48,57\>, \<57,64\>, \<64,75\>, \<74,82\> \} \end{aligned} <h3 id="存储结构"><a class="markdownIt-Anchor" href="#存储结构"></a> 存储结构</h3><p>在实际应用中，数据结构的存储方法是灵活多样的，归纳起来，数据结构中有以下4中常用的存储结构类型。</p><h4 id="顺序存储结构"><a class="markdownIt-Anchor" href="#顺序存储结构"></a> 顺序存储结构</h4><p>顺序存储结构（sequential storage structure）是采用一组连续的存储单元存放所有的数据元素。数据元素不仅在逻辑结构中相邻，由于顺序存储的方式，其在存储其中的存储位置也相邻。</p><p><em>优点</em>：存储效率高，可以实现对元素的随机存取。</p><p><em>缺点</em>：不便于数据修改，对元素的插入和删除操作可能需要移动一系列的元素。</p><h4 id="链式存储结构"><a class="markdownIt-Anchor" href="#链式存储结构"></a> 链式存储结构</h4><p>在链式存储结构（linked storge structure）中，每个逻辑元素单独分配一个内存节点，所有节点的内存地址是间断的，通过每个节点的附加指针连接起来，最终将所有的逻辑元素链接起来。</p><p><em>优点</em> ：方便数据修改（只需要修改前后节点的指针）。</p><p><em>缺点</em> ：不能对存储节点进行随机存取，存储效率相比顺序存储减半。</p><h4 id="索引存储结构"><a class="markdownIt-Anchor" href="#索引存储结构"></a> 索引存储结构</h4><p>索引存储结构（indexed storge structure）是指在存储元素信息的同时还建立附加的索引表。索引表中每一项称为索引项，其一般形式为“关键字，地址”，关键词用于标识某个特定元素，地址用于记录该元素的内存地址。通常为了便于查询，索引表中所有索引项是按关键字有序排列的。</p><p><em>优点</em> ：查找效率高</p><p><em>缺点</em> ：建立了索引表，增加了空间开销</p><h4 id="哈系或散列存储结构"><a class="markdownIt-Anchor" href="#哈系或散列存储结构"></a> 哈系（或散列）存储结构</h4><p>哈系存储结构（hashed storge structure）的基本思想是根据元素的关键字通过哈系函数直接计算出一个值，并将这个值作为该元素的存储地址。</p><p><em>优点</em> ：查找速度快，能够对元素进行快速的查找和插入</p><p><em>缺点</em> ：只存储元素的数据，不存储元素之间的逻辑关系（没有简便的方法以任何一种顺序遍历表中的数据项)；基于数组的哈系表，不便于扩展，在数组基本被填满后性能下降得非常严重</p><h3 id="数据运算"><a class="markdownIt-Anchor" href="#数据运算"></a> 数据运算</h3><p>数据运算是指对数据实施的操作。每种数据结构都有一组相应的运算，最常用的运算有检索、插入、删除、更新和排序等。数据运算最终需要在对应的存储结构上以特定的算法实现。</p><p>值得注意的一点是，运算的定义是基于逻辑结构层面，出于人们对解决现实问题的需要抽象出来的特定功能或者方法。运算的实现是基于存储结构层面，是依靠算法对具体的存储单元进行编程操作实现的。</p><p>运算之所有被分为这两种层面，我想，一方面虽然按书上说的“体现了软件工程的思想”，另一方面也导致了程序用户和程序员之间的分裂，使得一般的用户无法接触到程序内部的细节，只能被动地使用程序定义好的功能，而不能主动地凭自己的意见作修改。如果有那么一天，现实计算机的存储方式能够更加适合人类看待问题的方式，在迎合逻辑结构的同时，不再需要结构复杂的算法（才能保证稳定和效率）就能解决所有的问题，那么这里运算的两种层次的分裂将为被弥合。我想，届时人类可以利用计算机做到更多有趣的事情？</p><h3 id="数据类型和抽象数据类型"><a class="markdownIt-Anchor" href="#数据类型和抽象数据类型"></a> 数据类型和抽象数据类型</h3><p>这一部分还是自己在实践中掌握比较好</p><h2 id="算法及其描述"><a class="markdownIt-Anchor" href="#算法及其描述"></a> 算法及其描述</h2><h3 id="什么是算法"><a class="markdownIt-Anchor" href="#什么是算法"></a> 什么是算法？</h3><p>算法（algorithm）是对特定问题求解步骤的一种描述，它是指令有限的序列。其中每条指令代表计算机的一个或者多个操作。</p><p>一个算法应该具有一下5中重要的特性：</p><ol><li>有穷性：一个算法必须在有限步骤内完成。</li><li>确定性：对于每种情况执行的操作的都是确定的，即使说相同的输入总应该有同样的输出。</li><li>可行性：算法可以通过计算机基本操作的有限次组合来完成，否则计算机无法实现。</li><li>有输入：作为算法加工对象的量值，通常体现为一组变量，这是不可或缺的（可能程序员可以不要求任何变量的输入，但一个算法总是有特定加工处理的对象，比如void函数体内部的变量）。</li><li>有输出：作为算法对信息进行处理加工后的结构，一个算法有一个或者多个输出。</li></ol><p><em>算法输入和输出的特定关系构成了算法的功能</em>.</p><h3 id="算法设计的目标"><a class="markdownIt-Anchor" href="#算法设计的目标"></a> 算法设计的目标</h3><ol><li>正确性：算法能够正确地执行预先设定的功能和性能要求。这是最最基本的要求。</li><li>可实用性：要求程序能够方便地被使用，也称为用户友好性。</li><li>可读性：算法应该易于理解，这要求的算法的逻辑必须是清晰的、简单的和结构化的。</li><li>健壮性：要求算法具有较好的容错性，即提供异常处理。</li><li>高性能和低存储需求：要求尽可能节省算法时间和空间的开销。</li></ol><h3 id="算法描述"><a class="markdownIt-Anchor" href="#算法描述"></a> 算法描述</h3><p>简单介绍一下应该是有5种方法，可以用来描述一个确定的算法：</p><ol><li>自然语言：可以直接以通俗形象的语言来描述算法，尽管会丧失一定的严谨准确性。</li><li>流程图：适合顺序、循环结构的算法，不是具有递归结构的算法</li><li>伪代码：结合自然语言和程序语言，比较容易理解。</li><li>程序语言：最直接的描述方法</li><li>调用流程：以程序中函数为单位来描述算法的方法，适合一些复杂工程，也可以用来分析递归算法的成效。</li></ol><h2 id="算法分析"><a class="markdownIt-Anchor" href="#算法分析"></a> 算法分析</h2><h3 id="什么是算法分析"><a class="markdownIt-Anchor" href="#什么是算法分析"></a> 什么是算法分析？</h3><p>算法分析就是分析算法占用计算机资源的多少。而计算机资源主要是CPU时间和内存空间，因此算法分析又分为时间性能分析和空间性能分析。</p><h3 id="算法时间性能分析"><a class="markdownIt-Anchor" href="#算法时间性能分析"></a> 算法时间性能分析</h3><p>一般来说，有两种衡量算法时间性能的方法，即事后统计法和事前估计法。（按字面意思就很好理解）</p><p>而在设计算法的过程最常用的是事前估计的方法，一般我们称之为算法的时间复杂度分析。</p><p>算法的时间复杂度分析一般分为两步（熟练的Oier大概可以之间看出来，<br />不过对于涉及递归的算法，分析起来可能有一些困难）：第一步，首先，假设算法的问题规模为n，以程序的每一条语句为单位，为不同类型的语句设定一个耗时量，考虑每条语句的运行次数，最后将这些时间统计起来。如果追求精细，可以了解一下C/C++语言运行赋值语句，声明语句，运算语句的耗时（例如：<code>getchar()</code>, <code>printf()</code>, <code>cin</code>这三类输入语句其实有很大的性能差距，很多OIer为追求几十毫秒的性能，甚至会自己为程序写一个快速读入、输出函数来优化性能）。反之，如果仅仅是粗略分析一下，时间复杂度的量级，可以仅仅统计循环结构中的语句和执行次数并且不考虑不同语句的执行效率一视同仁地记为单位1即可。</p><p>第二步是将计算得到的时间函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 进一步略去其低阶项和常数，仅考虑时间增长趋势的一个上界。例如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T(n) = 2n^2 + 2n + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 这是我们可以直接取为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(f(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 是同阶无穷大的意思）</p><h3 id="算法的空间性能分析"><a class="markdownIt-Anchor" href="#算法的空间性能分析"></a> 算法的空间性能分析</h3><p>这部分由于书上介绍的比较简单，我也不想再过多介绍。一般，只要熟悉了程序中各个变量的生命（什么时候获取空间，什么时候释放空间），就足够分析清楚算法的空间复杂度了。</p><h2 id="数据结构算法程序"><a class="markdownIt-Anchor" href="#数据结构算法程序"></a> 数据结构+算法=程序</h2><ul><li><a href="/2021/10/1238/index.html">在本书中提到的概念</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据结构与算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据结构与算法&quot;&gt;&lt;/a&gt; 数据结构与算法&lt;/h1&gt;
&lt;h2 id=&quot;什么是数据结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是数据结构&quot;&gt;&lt;/a&gt; 什么是数据结构？&lt;/h2&gt;
&lt;p&gt;要理解数据结构，首先从目的、功能的角度看。计算机要解决一个具体的问题，大致需要经过如下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分析问题，确定数据模型&lt;/li&gt;
&lt;li&gt;设计相应的算法&lt;/li&gt;
&lt;li&gt;编写程序，运行并调试，直至得到正确的结果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里提出了一个概念叫做 &lt;strong&gt;数据模型&lt;/strong&gt; 。作为一个数学系应用数学专业的学生，我一个想到的是既然都叫做模型，那么数据模型和数学模型有什么异同呢？&lt;/p&gt;
&lt;p&gt;首先一个最令人困惑的问题是数学、数据，这两个词到底有什么区别？（我最近比较喜欢用这种分析语义语词的方式理解问题）。参考百度上的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数学&lt;/strong&gt; 作为学科，其目的在于研究数量、结构、变化、空间以及信息等概念。作为思维方法，是人类对事物的抽象结构与模式进行严格描述的一种通用手段。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;与其说是通用手段，不如说每每当人类将问题给抽象化，特征化，便无可避免地使用（亦或是发明）某种“数学”&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据&lt;/strong&gt; 作为类，是指对客观事件进行记录并可以鉴别的符号，是对客观事物的逻辑归纳。数据经过加工和处理成为可被解读的信息。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://www.wenwenziy.live/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法" scheme="http://www.wenwenziy.live/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Day day up" scheme="http://www.wenwenziy.live/tags/Day-day-up/"/>
    
  </entry>
  
  <entry>
    <title>概念集</title>
    <link href="http://www.wenwenziy.live/2021/10/%E6%A6%82%E5%BF%B5%E9%9B%86/"/>
    <id>http://www.wenwenziy.live/2021/10/%E6%A6%82%E5%BF%B5%E9%9B%86/</id>
    <published>2021-10-02T16:00:00.000Z</published>
    <updated>2021-10-07T15:31:10.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于数据结构的一些概念"><a class="markdownIt-Anchor" href="#关于数据结构的一些概念"></a> 关于数据结构的一些概念</h1><h4 id="数据-data"><a class="markdownIt-Anchor" href="#数据-data"></a> 数据 data</h4><ol><li>是描述客观事物的数和字符的集合。</li><li>从计算机的角度来看，数据是所有能被输入到计算机中，且能够被计算机处理的符号的集合，它是计算机操作对象的总称。</li></ol><h4 id="数据项-data-item"><a class="markdownIt-Anchor" href="#数据项-data-item"></a> 数据项 data item</h4><p>是具有独立含义的数据的最小单位，也称为字段或者域。例如学生在教务系统中的统计数据就包含了其学号、年级、班级等信息。</p><h4 id="数据对象-data-object"><a class="markdownIt-Anchor" href="#数据对象-data-object"></a> 数据对象 data object</h4><p>是指性质相同的数据元素的集合，它是数据的一个子集。</p><h4 id="数据结构-data-structure"><a class="markdownIt-Anchor" href="#数据结构-data-structure"></a> 数据结构 data structure</h4><p>是指所有数据元素以及数据元素之间的关系，可以看作是相互之间存在着某种特定关系的数据元素的集合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于数据结构的一些概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关于数据结构的一些概念&quot;&gt;&lt;/a&gt; 关于数据结构的一些概念&lt;/h1&gt;
&lt;h4 id=&quot;数据-data&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr</summary>
      
    
    
    
    <category term="概念集" scheme="http://www.wenwenziy.live/categories/%E6%A6%82%E5%BF%B5%E9%9B%86/"/>
    
    <category term="数据结构与算法" scheme="http://www.wenwenziy.live/categories/%E6%A6%82%E5%BF%B5%E9%9B%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Day day up" scheme="http://www.wenwenziy.live/tags/Day-day-up/"/>
    
  </entry>
  
  <entry>
    <title>My First Article</title>
    <link href="http://www.wenwenziy.live/2021/09/2021-9-my-new-article/"/>
    <id>http://www.wenwenziy.live/2021/09/2021-9-my-new-article/</id>
    <published>2021-09-26T14:56:04.000Z</published>
    <updated>2021-10-07T15:31:10.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>既然是我博客里的第一篇文章，那我就来摸索一下这里的各种功能好了。<br />首先list一下，我的根目录里的npm清单：</p><pre><code>exo-site@0.0.0 /Users/jasmine/jasmines_blog├── @upupming/hexo-renderer-markdown-it-plus@2.0.2├── hexo-browsersync@0.3.0├── hexo-deployer-git@3.0.0├── hexo-generator-archive@1.0.0├── hexo-generator-category@1.0.0├── hexo-generator-feed@3.0.0├── hexo-generator-index@2.0.0├── hexo-generator-sitemap@2.1.0├── hexo-generator-tag@1.0.0├── hexo-math@4.0.0├── hexo-renderer-ejs@1.0.0├── hexo-renderer-jade@0.5.0├── hexo-renderer-stylus@2.0.1├── hexo-server@2.0.0└── hexo@5.4.0</code></pre><ol><li><code>hexo-renderer-markdown-it-plus</code> 为了写latex重新更换的渲染引擎。之所以要更换，是因为在网上hexo原先的 <code>hexo-renderer-marked</code> 引擎，有许多符号会和latex里的符号重复，哪怕下载了支持mathjex的插件写tex 的时候也需要加上许多转义符，故放弃。</li><li><code>hexo-browsersync</code> 这个应该是 hexo 自带的一个插件。如同字面意思，这个插件会在你的<code>hexo server</code>启动后，当你进行了任何文件上的更改时，实时地在浏览器端口，重新加载新的内容，帮助你实时编辑并查看效果。</li><li><code>hexo-deployer-git</code> 这是一个需要手动安装的插件，可以通过 <code>hexo deploy --git</code> 命令帮助将hexo生成的静态文件上传至 github page。</li><li><code>hexo-generator-xxx</code> 这一块是负责特定页面的生成器，比如archieve就对应 <code>hexo-generator-archieve</code>。每个生成器大体作用是在接受到用户端的请求的时候，通过重建路由，更新页面的内容。（官方文档里只有很短的一行字：根据处理后的原始文件建立路由）。</li><li><code>hexo-renderer-xxx</code> hexo负责渲染页面的渲染器，大体理解是将markdown里的标记翻译为html的页面。</li><li><code>hexo-server</code> 这也是一个需要手动安装的插件，它可以帮助你在本地端口查看编辑好的页面。使用方法是在终端输入 <code>hexo server</code> 命令。</li><li><code>hexo</code> 本体，提供了<code>hexo</code>的核心以及所有的api，更多内容参看官方文档。目前我对node.js和前后端的整体工作流程还没有了解，大概还要很久才能真正掌握这里的内容，理解hexo是如何工作的。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;既然是我博客里的第一篇文章，那我就来摸索一下这里的各种功能好了。&lt;br /&gt;
首先list一下，我的根目录里的npm清单：&lt;/p&gt;
&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="编程" scheme="http://www.wenwenziy.live/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="hexo 配置手册" scheme="http://www.wenwenziy.live/categories/%E7%BC%96%E7%A8%8B/hexo-%E9%85%8D%E7%BD%AE%E6%89%8B%E5%86%8C/"/>
    
    
    <category term="A bored begining" scheme="http://www.wenwenziy.live/tags/A-bored-begining/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.wenwenziy.live/2021/09/2021-9-hello-world/"/>
    <id>http://www.wenwenziy.live/2021/09/2021-9-hello-world/</id>
    <published>2021-09-25T16:00:00.000Z</published>
    <updated>2021-10-07T15:31:10.439Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章来自Hexo官方的示例文档，快速介绍了hexo的几条常用命令，以及详细介绍它们的链接。我的Blog才刚刚上手，暂时还不知道应不应该把它们删掉，于是就放在在这。如果以后，仔细研究清楚这些命令的作用，说不定会在这里做一些补充。</p><span id="more"></span><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章来自Hexo官方的示例文档，快速介绍了hexo的几条常用命令，以及详细介绍它们的链接。我的Blog才刚刚上手，暂时还不知道应不应该把它们删掉，于是就放在在这。如果以后，仔细研究清楚这些命令的作用，说不定会在这里做一些补充。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
